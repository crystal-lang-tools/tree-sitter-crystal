==============
pseudo methods
==============

class ClassName
  def initialize
    self.is_a?(Object)
    self.nil?
    typeof(self, other) # works
    sizeof(self.class) # works
    instance_sizeof(self.class) # works
    pointerof(self)
    offsetof(self.class, 1) # works
    self.as(Object)
    self.as?(Object)
    responds_to?(:method)
    self.!
  end
end

---

(expressions
  (class_def
    (constant)
    (expressions
      (method_def
        (identifier)
        (expressions
          (call
            (self)
            (identifier)
            (argument_list
              (constant)))
          (call
            (self)
            (identifier))
          (typeof
            (self)
            (identifier))
          (comment)
          (sizeof
            (class_type
              (self)))
          (comment)
          (instance_sizeof
            (class_type
              (self)))
          (comment)
          (call
            (identifier)
            (argument_list
              (self)))
          (offsetof
            (class_type
              (self))
            (integer))
          (comment)
          (call
            (self)
            (identifier)
            (argument_list
              (constant)))
          (call
            (self)
            (identifier)
            (argument_list
              (constant)))
          (call
            (identifier)
            (argument_list
              (symbol)))
          (call
            (self)
            (operator)))))))

=======================
misc keywords / methods
=======================

super
previous_def
uninitialized Class

---

(expressions
  (identifier)
  (identifier)
  (call
    (identifier)
    (argument_list
      (constant))))

==========================
fun def params on newlines
:error
==========================

fun
extreme_fun
(
param1
:
Type
,
param2
:
Type
)
:
ReturnType
  puts "hello"
end

---

(expressions
  (fun_def
    name: (identifier)
    body: (expressions
      (identifier)
      (ERROR)
      (constant)
      (ERROR)
      (identifier)
      (ERROR)
      (constant))
    (ERROR)
    body: (constant)
    body: (call
      method: (identifier)
      arguments: (argument_list
        (string)))))

============================
.as method with pointer type
:error
============================

node.as(LibXML::Node*)

---

(expressions
  (call
    (identifier)
    (identifier)
    (argument_list
      (op_call
        (constant)
        (operator)
        (MISSING identifier)))))

=================================
Array-like and hash-like literals
:error
=================================

Set{1, 2, 3}
MyType{"foo" => "bar"}

---



==========================
symbols ending with equals
:error
==========================

:hello=
:world==world
:world == world

---

(expressions
  (symbol)
  (symbol)
  (ERROR
    (identifier))
  (call
    (symbol)
    (operator)
    (identifier)))

=================================
case expression with typed tuples
:error
=================================

case {value, this_value}
in {String, String}
	puts "hello"
in {Int32, false}
	puts "world"
end

---



=============================================================
private or protected calls with keyword type declaration args
=============================================================

class Name
  private getter private : Qux
end

---

(expressions
  (class_def
    name: (constant)
    (ERROR
      (private)
      (identifier)
      (private)
      (ERROR)
      (constant))))

================================================================================
implicit object assignment call
:error
================================================================================
inner.try &.color=(color)
--------------------------------------------------------------------------------

(expressions)

================
fun void pointer
================

lib MyLib
  type VoidProc = Void* -> Void*, Void*
end

---

(expressions
  (lib_def
    (constant)
    (expressions
      (type_def
        (constant)
        (proc_type
          (pointer_type
            (constant))
          (ERROR
            (pointer_type
              (constant)))
          (pointer_type
            (constant)))))))
